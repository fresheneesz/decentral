var EventEmitter = require("events").EventEmitter
var proto = require("proto")
var rpep = require("rpep")
var websockets = require("rpep-websockets/ws.node")
var webrtc = require("rpep-webrtc/rpep-webrtc.node")
var msgpack = require("rpep-msgpack")
var decentralWebrtc = require("rpep-decentral-webrtc")
var constants = require("constants")

function createRpepPeer() {
    var rpepPeer = rpep(decentralWebrtc({
        signalServerTransport: websockets(), rtcTransport: webrtc()
    }), msgpack)
    rpepPeer.on('error', function(e) {
        console.error(e)
    })
    rpepPeer.respond('hi', function() {
        console.log("hi")
        return 'wassup'
    })
    return rpepPeer
}

// A Peer Connection.
// Emits events:
// * connected
// * disconnected
var Peer = module.exports = proto(EventEmitter, function() {

    // Static methods

    this.listenForPeer = function(signalServerHost, handler) {
        var rpepPeer = createRpepPeer()
        rpepPeer.listen({
            signalServerHost: signalServerHost,
            signalServerPort: constants.signalServerPort
        }, function(request) {
            handler(request)
        })
        return rpepPeer
    }

    // Instance methods

    this.init = function(addressInfo, connection) {
        EventEmitter.apply(this)
        this.addressInfo = addressInfo
        // this.conn
        if(connection) {
            this.initializeConnection(connection)
        }
    }

//    // Gets the quality value used to determine which connection has been of more value.
//    this.getValue = function() {
//        return this.quality + this.usefulDataReceived/(this.usefulDataSent+this.usefulDataReceived)
//    }

    this.connect = function() {
        if(this.conn) throw new Error("Already connected.")

        var that = this
        var rpepPeer = createRpepPeer()
        rpepPeer.connect({
            peerAddress: that.addressInfo.peerAddress,
            signalServerHost: that.addressInfo.signalServerHost,
            signalServerPort: that.addressInfo.signalServerPort
        }).then(function(conn) {
            that.initializeConnection(conn)
        }).catch(function(e) {
            console.log(e+"<br>\n"+ (e.errors||[]).join('<br>\n'))
            that.disconnect()
        })
        return rpepPeer
    }

    this.listenOn = function(handler) {
        if(!this.connected()) throw new Error("Can't listen on connection that isn't open.")

        this.listenForPeer(this.conn.rawConnection.remoteAddress, handler)
    }

    this.initializeConnection = function(conn) {
        var that = this
        this.conn = conn
        this.emit('connected')
        conn.request('hi').then(function(response) {
            console.log(response)
        })
        conn.on('close', function() {
            console.log("Bye")
            that.disconnect()
        })
        conn.on('error', function(e) {
            if(e.code === 'ERR_ICE_CONNECTION_FAILURE') {
                console.log(e)
            } else {
                throw e
            }
        })
    }

//    this.verifyIdentity = function() {
//        var randomChallenge = randomInt();
//        var response = this.request('verifyIdentity', randomChallenge)
//        return crypt.verify(this.pubkey, randomChallenge, response.signature)
//    }

    this.request = function() {
        this.conn.request.apply(this.conn, arguments)
    }

    this.connected = function() {
        return this.conn !== undefined && this.conn.connected()
    }

    this.disconnect = function() {
        if(this.connected()) {
            this.conn.disconnect()
        }
        this.conn = undefined
        this.emit('disconnected')
    }

    this.reduceQuality = function() {

    }
})

//this.connectToNode = function(node) {
//    node.connect()
//    if(node.connected()) {
//        if(node.pubkey === this.pubkey) {
//            node.disconnect()
//            return // Don't connect to yourself.
//        }
//
//        this.connections.push(node)
//        var that = this
//        node.on('disconnected', function() {
//            that.connections.remove(node)
//            // todo: connect to a new node to replace the old one
//        })
//        this.emit('newConnection', node)
//    }
//}

//this.getPublicKey = function() {
//    var pubkey = this.networkData.get('pubkey', {limit: 1})
//    if(pubkey === undefined) {
//        pubkey = crypt.generatePubkey()
//        this.networkData.insert('pubkey', pubkey)
//    }
//    return pubkey
//}
