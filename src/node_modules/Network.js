var EventEmitter = require("events").EventEmitter
var proto = require('proto')
var signalServer = require("signalServer")

//var Database = require("Database")
var Peer = require("Peer")
var AddressDatabase = require("AddressDatabase")

module.exports = proto(EventEmitter, function() {

    // config
        // Peer - An extension of the Peer class, which represents a connection to a peer.
        // maxIncomingConnections - Default 14.
        // maxOutgoingConnections - Default 14.
        // addressSeedList - An array of peer addresses or address sources in priority order of what to try
        //                   first. where each object has the following properties:
        // * type - Either 'peer' or 'list'.
        // * address - If type is 'peer', this address is the address of a peer to connect to. If type
        //             is 'list', this is an http hostname that returns a list of peer addresses as a csv.
        //             Each peer address is an object with the following three parts:
        //   * signalServerHost
        //   * signalServerPort
        //   * peerAddress
    this.init = function(config) {
        EventEmitter.apply(this)

        this.Peer = config.Peer || Peer
        validateAddressSeedList(config.addressSeedList)
        this.addressDatabase = AddressDatabase(config.addressSeedList || [])
        this.maxIncomingConnections = config.maxIncomingConnections || 14
        this.maxOutgoingConnections = config.maxOutgoingConnections || 14

        this.outgoingConnections = []
        this.incomingConnections = []
        this.state = 'disconnected' // 'connecting', 'connected', 'disconnecting'
        // this.networkData = Database('network')
        // this.pubkey = this.getPublicKey()
        // this.listeningServer
    }

    this.connect = function() {
        if(this.state in {connecting:1, connected:1}) {
            return // noop
        } else if(this.state === 'disconnected') {
//            this.refillOutgoingConnections()
            this.listen()
        } else {
            throw new Error("Connecting while disconnecting not supported yet.")
        }
    }

    this.disconnect = function() {
        if(this.state in {disconnecting:1, disconnected:1}) {
            return // noop
        } else if(this.state === 'connected') {
            this.outgoingConnections.concat(this.incomingConnections).forEach(function(peer) {
                peer.disconnect()
                this.listening = false
            })
        } else {
            throw new Error("Disconnecting while connecting not supported yet.")
        }
    }

    // private

    // Refills outgoing connections to the max.
    this.refillOutgoingConnections = function() {
        var that = this
        var peersNeeded = this.maxOutgoingConnections - that.outgoingConnections.length

        for(var n=0; n<peersNeeded; n++) {
            this.addressDatabase.getNextAddress().then(function(addressInfo) {
                return that.connectTo(addressInfo)
            })

        }
    }

    this.listen = function() {
        if(this.listening) throw new Error("Already listening.")
        this.listening = true

        var that = this
        var port = 8080
        startSignalServer(port)

        function startSignalServer(port) {
            var server = signalServer(port)
            server.on('error', function(e) {
                if(e.code === 'EADDRINUSE') {
                    startSignalServer(port+1)
                } else {
                    that.emit('error', e)
                }
            })
        }

        // Listen on connected connections
        this.outgoingConnections.concat(this.incomingConnections).forEach(function(peer) {
            if(peer.connected()) {
                peer.listenOn(function(request) {
                    that.newPeerHandler(request)
                })
            }
        })

        // Connect to your own signal server.
        var listeningPeer = Peer.listenForPeer('localhost', function(request) {
            that.newPeerHandler(request)
        })
        listeningPeer.on('listening', function() {
            console.log("Listening with name: "+listeningPeer.listener.rawHandle.name)
        })
    }

    // address - Should be an AddressInfo object from the AddressDatabase
    this.connectTo = function(addressInfo) {
        var that = this
        var peer = this.Peer(addressInfo)
        that.outgoingConnections.push(peer)
        peer.connect()
        peer.on('connected', function() {
            peer.listenOn(function(request) {
                that.newPeerHandler(request)
            })
        })
        peer.on('disconnect', function() {
            var peerIndex = that.outgoingConnections.indexOf(peer)
            that.outgoingConnections.splice(peerIndex, 1)
            that.refillOutgoingConnections()
        })
    }

    this.newPeerHandler = function(request) {
        var that = this
        var item = that.addressDatabase.findAddressInUse(request.remoteAddress)
        if(item) {
            console.log("Duplicate connection")
            // Todo: uncomment this:
            // return request.reject() // Don't make duplicate connections
        } else if(that.incomingConnections.length >= that.maxIncomingConnections) {
            console.log("Incoming connections already full.")
            return request.reject()
        } else {
            // Add node to database
            that.addressDatabase.add([{
                peerAddress: request.remoteAddress,
                signalServerHost: peer.conn.rawConnection.remoteAddress,
                signalServerPort: peer.conn.rawConnection.remotePort
            }])
            item = that.addressDatabase.findAddressInUse(request.remoteAddress)
        }

        var conn = request.accept()
        var newPeer = Peer(item, conn)
        that.incomingConnections.push(newPeer)
        newPeer.on('connected', function() {
            that.listenOnPeer(newPeer)
        })
        newPeer.on('disconnect', function() {
            var peerIndex = that.incomingConnections.indexOf(newPeer)
            that.incomingConnections.splice(peerIndex, 1)
        })
    }
})

function validateAddressSeedList(addressSeedList) {
    if(addressSeedList === undefined) return
    addressSeedList.forEach(function(item) {
        if(!(item.type in {peer:1,list:1})) {
            throw new Error("Invalid addressSeedList type: "+item.type)
        }
    })
}