var EventEmitter = require("events").EventEmitter
var rpep = require("rpep")
var msgpack = require("rpep-msgpack")

var errorCodes = {
    SIGNAL_SERVER_ERROR: {},
    SIGNAL_SERVER_STREAM_ERROR: {},
    SIGNAL_SERVER_CONNECTION_ERROR: {}
}

// This is an decentral webrtc transport for rpep. It includes a protocol for signaling for initiation of a webrtc connection.
// config
    // signalServerTransport - The RPEP transport for communicating with the signal server.
    // rtcTransport - The rpep-webrtc transport appropriate for the environment.
module.exports = function(transportConfig) {
    return {
        // config
            // peerAddress - The address of the peer to connect to.
            // signalServerHost - Signal server hostname.
            // signalServerPort - Signal server port.
            // channelConfig - (Optional) Webrtc data channel configuration (used by createDataChannel - https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/createDataChannel)
            // rtcConfig - (Optional) Webrtc configuration (used by RTCPeerConnection constructor - https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)
        connect: function(config, rpepOptions) {
            var connectionPromise = new Promise(function(resolve, reject) {
                var signalServer = rpep(transportConfig.signalServerTransport, msgpack)
                signalServer.connect(config.signalServerHost, config.signalServerPort).then(function(signalServerConnection) {
                    signalServerConnection.on('error', function(e) {
                        end()
                        reject(err(e, "SIGNAL_SERVER_ERROR", "Signal server error: "+e.message))
                    })
                    var stream = signalServerConnection.streamConnect('connect', config.peerAddress)
                    stream.on('accepted', function() {
                        var remoteSignalEmitter = new EventEmitter
                        stream.on('signal', function(responseSignal) {
                            remoteSignalEmitter.emit('signal', responseSignal)
                        })

                        var transportConnectionObj = transportConfig.rtcTransport.connect({
                            channelConfig: config.channelConfig,
                            config: config.rtcConfig,
                            remoteSignalEmitter: remoteSignalEmitter,
                            sendSignal: function(signal) {
                                stream.emit("signal", signal)
                            }
                        }, rpepOptions)

                        transportConnectionObj.onOpen(function() {
                            stream.emit("end")
                        })

                        resolve(transportConnectionObj)
                    })
                    stream.on('rejected', function(reason) {
                        end(stream)
                        var message = "Connection rejected"
                        if(reason) message += ": "+reason
                        reject(reason, "CONNECTION_REJECTED", message)
                    })
                    stream.on('error', function(e) {
                        end(stream)
                        reject(err(e, "SIGNAL_SERVER_STREAM_ERROR", "Signal server error: "+e.message))
                    })

                    function end(stream) {
                        if(stream) stream.emit("end")
                        if(!signalServerConnection.closing)
                            signalServerConnection.close()
                    }
                }).catch(function(e) {
                    reject(err(e, "SIGNAL_SERVER_CONNECTION_ERROR", e.message))
                })
            })

            return createConnection(connectionPromise)
        },

        // config - All items are the same as the `connect` config parameters of the same name.
            // signalServerHost
            // signalServerPort
            // channelConfig
            // rtcConfig
        listen: function(config, rpepOptions, requestHandler) {
            var offerEmitter = new EventEmitter
            var rtcListenConfig = {
                offerEmitter: offerEmitter, channelConfig: config.channelConfig, config: config.rtcConfig
            }
            var transportListenerObj = transportConfig.rtcTransport.listen(rtcListenConfig, rpepOptions, requestHandler)

            var connection, signalServerListeningStream, endSentOnClose = false
            var signalServer = rpep(transportConfig.signalServerTransport, msgpack)
            signalServer.stream('newPeer', function(stream) {
                var remoteSignalEmitter = new EventEmitter
                signalServerListeningStream = stream
                stream.on('signal', function(responseSignal) {
                    remoteSignalEmitter.emit('signal', responseSignal)
                })
                stream.on('end', function() {
                    if(!endSentOnClose) stream.emit("end") // End the stream (but not the connection).
                    signalServerListeningStream = undefined
                    offerEmitter.emit('close')
                })

                offerEmitter.emit('newPeer', {}, remoteSignalEmitter, function sendSignal(signal) {
                    stream.emit("signal", signal)
                }, function rejectRequest() {
                    stream.emit('reject')
                })

                stream.emit('accept')
            })

            var signalServerConnectionPromise = signalServer.connect(config.signalServerHost, config.signalServerPort).then(function(conn) {
                connection = conn
                return conn.request('register')
            }).then(function(name){
                console.log("Listening with name: "+name)
                listener.rawHandle.name = name
                offerEmitter.emit('listening')
            }).catch(function(e) {
                if(!errorHandler) {
                    var err = new Error("No error handler to handle: "+e)
                    err.cause = e
                    throw err
                }
            })

            var errorHandler
            var listener = {
                close: function() {
                    new Promise(function(resolve, reject) {
                        if(connection) connection.close()
                        if(signalServerListeningStream) {
                            signalServerListeningStream.emit('end')
                            endSentOnClose = true
                            offerEmitter.on('close', resolve)
                        } else {
                            resolve()
                        }
                    }).then(function() {
                        signalServer.close()
                        transportListenerObj.close()
                    }).catch(function(e) {
                        if(errorHandler) {
                            errorHandler(e)
                        } else throw e
                    })
                },
                onListening: function(cb) {
                    transportListenerObj.onListening(cb)
                },
                onClose: function(cb) {
                    transportListenerObj.onClose(cb)
                },
                onError: function(cb) {
                    signalServerConnectionPromise.catch(cb)
                    signalServer.on('error', cb)
                    transportListenerObj.onError(cb)
                    errorHandler = cb
                },
                rawHandle: {}
            }
            return listener
        }
    }
}

function createConnection(connectionPromise) {
    var errorHandler, closeHandlers = [], connectionHasBeenOpened = false
    connectionPromise.then(function(transportConnectionObj){
        connectionHasBeenOpened = true
        transportConnection.rawConnection = transportConnectionObj
    }).catch(function(e) {
        if(!errorHandler) {
            var err = new Error("No error handler to handle: "+e)
            err.cause = e
            throw err
        }
        closeHandlers.forEach(function(signalClosed) {
            signalClosed()
        })
    })

    var noop = function(){}
    var transportConnection = {
        send: function(m) {
            if(transportConnection.rawConnection) {
                transportConnection.rawConnection.send(m)
            } else {
                connectionPromise.then(function(transportConnectionObj){
                    transportConnectionObj.send(m)
                }).catch(noop)
            }
        },
        close: function() {
            connectionPromise.then(function(transportConnectionObj){
                transportConnectionObj.close()
            }).catch(noop)
        },
        onOpen: function(cb) {
            connectionPromise.then(function(transportConnectionObj){
                transportConnectionObj.onOpen(cb)
            }).catch(noop)
        },
        onClose: function(cb) {
            closeHandlers.push(cb)
            connectionPromise.then(function(transportConnectionObj){
                transportConnectionObj.onClose(cb)
            }).catch(noop)
        },
        onMessage: function(cb) {
            if(transportConnection.rawConnection) {
                transportConnection.rawConnection.onMessage(cb)
            } else {
                connectionPromise.then(function(transportConnectionObj){
                    transportConnectionObj.onMessage(cb)
                }).catch(noop)
            }
        },
        onError: function(cb) {
            errorHandler = cb
            connectionPromise.then(function(transportConnectionObj){
                transportConnectionObj.onError(cb)
            }).catch(cb)
        }
        // rawConnection: undefined // Will be populated on connection
    }

    return transportConnection
}

function err(e, code, message) {
    var error = new Error(message)
    error.handle = errorCodes[code]
    error.code = code
    error.cause = e
    return error
}